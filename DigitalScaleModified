import tkinter as tk
from tkinter import messagebox, ttk
import sqlite3
from datetime import datetime
import pytz
import pygame
import random
import csv

class DigitalScaleApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Modified Digital Scale")
        self.root.geometry("500x600")

        # Initialize Pygame for sound
        pygame.mixer.init()

        # Initialize SQLite database
        self.conn = sqlite3.connect("scale_measurements.db")
        self.create_table()

        # Timezone (UTC+03:00)
        self.timezone = pytz.timezone("Asia/Riyadh")

        # Scale variables
        self.unit = "kg"
        self.current_weight = 0.0

        # GUI Elements
        self.theme = "dark"
        self.root.configure(bg="#2C2C2C" if self.theme == "dark" else "#FFFFFF")

        # Weight display
        self.weight_var = tk.StringVar(value="0.00 kg")
        tk.Label(root, textvariable=self.weight_var, font=("Arial", 40, "bold"), fg="white" if self.theme == "dark" else "black", bg="#2C2C2C" if self.theme == "dark" else "#FFFFFF").pack(pady=10)

        # Theme selection
        tk.Label(root, text="Select Theme:", font=("Arial", 12), fg="white" if self.theme == "dark" else "black", bg="#2C2C2C" if self.theme == "dark" else "#FFFFFF").pack()
        self.theme_var = tk.StringVar(value="Dark")
        ttk.Combobox(root, textvariable=self.theme_var, values=["Dark", "Light"], state="readonly").pack()
        self.theme_var.trace("w", self.update_theme)

        # Unit selection
        tk.Label(root, text="Select Unit:", font=("Arial", 12), fg="white" if self.theme == "dark" else "black", bg="#2C2C2C" if self.theme == "dark" else "#FFFFFF").pack(pady=5)
        self.unit_var = tk.StringVar(value="kg")
        ttk.Combobox(root, textvariable=self.unit_var, values=["kg", "lb"], state="readonly").pack()
        self.unit_var.trace("w", self.update_weight_display)

        # Category selection
        tk.Label(root, text="Category:", font=("Arial", 12), fg="white" if self.theme == "dark" else "black", bg="#2C2C2C" if self.theme == "dark" else "#FFFFFF").pack(pady=5)
        self.category_var = tk.StringVar(value="General")
        ttk.Combobox(root, textvariable=self.category_var, values=["General", "Food", "Person", "Object", "Other"], state="readonly").pack(pady=5)

        # Weight input (for manual entry)
        tk.Label(root, text="Enter Weight:", font=("Arial", 12), fg="white" if self.theme == "dark" else "black", bg="#2C2C2C" if self.theme == "dark" else "#FFFFFF").pack()
        self.weight_entry = tk.Entry(root, font=("Arial", 12))
        self.weight_entry.pack(pady=5)

        # Buttons
        tk.Button(root, text="Record Weight", command=self.record_weight, font=("Arial", 12)).pack(pady=5)
        tk.Button(root, text="Generate Random Weight", command=self.generate_random_weight, font=("Arial", 12)).pack(pady=5)
        tk.Button(root, text="View Measurements", command=self.view_measurements, font=("Arial", 12)).pack(pady=5)
        tk.Button(root, text="View Statistics", command=self.view_statistics, font=("Arial", 12)).pack(pady=5)
        tk.Button(root, text="Export to CSV", command=self.export_to_csv, font=("Arial", 12)).pack(pady=5)

        # Update weight display
        self.update_weight_display()

    def create_table(self):
        cursor = self.conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS measurements (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                weight REAL NOT NULL,
                unit TEXT NOT NULL,
                category TEXT NOT NULL
            )
        ''')
        self.conn.commit()

    def visual_feedback(self, success=True):
        color = "green" if success else "red"
        for _ in range(3):
            self.root.configure(bg=color)
            self.weight_var.set("RECORDED!" if success else "ERROR!")
            self.root.update()
            self.root.after(100)
            self.root.configure(bg="#2C2C2C" if self.theme == "dark" else "#FFFFFF")
            self.update_weight_display()
            self.root.update()
            self.root.after(100)

    def play_sound(self):
        try:
            pygame.mixer.Sound("measure.wav").play()
        except:
            pass  # Skip sound if file not found

    def update_theme(self, *args):
        self.theme = self.theme_var.get().lower()
        bg_color = "#2C2C2C" if self.theme == "dark" else "#FFFFFF"
        fg_color = "white" if self.theme == "dark" else "black"
        self.root.configure(bg=bg_color)
        for widget in self.root.winfo_children():
            if isinstance(widget, tk.Label):
                widget.configure(bg=bg_color, fg=fg_color)

    def update_weight_display(self, *args):
        self.unit = self.unit_var.get()
        weight = self.current_weight
        if self.unit == "lb":
            weight *= 2.20462  # Convert kg to lb
        self.weight_var.set(f"{weight:.2f} {self.unit}")

    def record_weight(self):
        weight_input = self.weight_entry.get().strip()
        try:
            weight = float(weight_input)
            if weight < 0:
                raise ValueError
        except ValueError:
            messagebox.showerror("Error", "Enter a valid non-negative weight!")
            self.visual_feedback(success=False)
            return

        # Convert to kg for storage
        stored_weight = weight if self.unit == "kg" else weight / 2.20462
        timestamp = datetime.now(self.timezone).strftime("%Y-%m-%d %H:%M:%S")
        category = self.category_var.get()

        # Save to database
        cursor = self.conn.cursor()
        cursor.execute("INSERT INTO measurements (timestamp, weight, unit, category) VALUES (?, ?, ?, ?)",
                      (timestamp, stored_weight, self.unit, category))
        self.conn.commit()

        self.current_weight = stored_weight
        self.update_weight_display()
        messagebox.showinfo("Success", f"Weight {weight:.2f} {self.unit} recorded!")
        self.visual_feedback(success=True)
        self.play_sound()
        self.weight_entry.delete(0, tk.END)

    def generate_random_weight(self):
        # Simulate a scale reading (0-100 kg for realism)
        self.current_weight = random.uniform(0, 100)
        self.update_weight_display()
        messagebox.showinfo("Success", f"Random weight generated: {self.current_weight:.2f} kg")
        self.visual_feedback(success=True)
        self.play_sound()

    def view_measurements(self):
        window = tk.Toplevel(self.root)
        window.title("Measurement History")
        window.geometry("500x400")
        tree = ttk.Treeview(window, columns=("ID", "Timestamp", "Weight", "Unit", "Category"), show="headings")
        tree.heading("ID", text="ID")
        tree.heading("Timestamp", text="Timestamp")
        tree.heading("Weight", text="Weight")
        tree.heading("Unit", text="Unit")
        tree.heading("Category", text="Category")
        tree.column("ID", width=50)
        tree.column("Timestamp", width=150)
        tree.column("Weight", width=100)
        tree.column("Unit", width=80)
        tree.column("Category", width=100)
        tree.pack(fill="both", expand=True, padx=10, pady=10)
        cursor = self.conn.cursor()
        cursor.execute("SELECT id, timestamp, weight, unit, category FROM measurements")
        for row in cursor.fetchall():
            weight = row[2] if row[3] == "kg" else row[2] * 2.20462
            tree.insert("", tk.END, values=(row[0], row[1], f"{weight:.2f}", row[3], row[4]))

    def view_statistics(self):
        cursor = self.conn.cursor()
        cursor.execute("SELECT weight, unit FROM measurements WHERE category = ?", (self.category_var.get(),))
        weights = [row[0] if row[1] == "kg" else row[0] * 2.20462 for row in cursor.fetchall()]
        if not weights:
            messagebox.showinfo("Statistics", "No measurements recorded for this category!")
            return
        avg_weight = sum(weights) / len(weights)
        min_weight = min(weights)
        max_weight = max(weights)
        unit = self.unit_var.get()
        messagebox.showinfo("Statistics", f"Average Weight: {avg_weight:.2f} {unit}\nMin Weight: {min_weight:.2f} {unit}\nMax Weight: {max_weight:.2f} {unit}")

    def export_to_csv(self):
        cursor = self.conn.cursor()
        cursor.execute("SELECT id, timestamp, weight, unit, category FROM measurements")
        with open("scale_measurements.csv", "w", newline="") as file:
            writer = csv.writer(file)
            writer.writerow(["ID", "Timestamp", "Weight", "Unit", "Category"])
            for row in cursor.fetchall():
                weight = row[2] if row[3] == "kg" else row[2] * 2.20462
                writer.writerow([row[0], row[1], f"{weight:.2f}", row[3], row[4]])
        messagebox.showinfo("Success", "Measurements exported to scale_measurements.csv!")
        self.visual_feedback(success=True)
        self.play_sound()

    def __del__(self):
        self.conn.close()

if __name__ == "__main__":
    root = tk.Tk()
    app = DigitalScaleApp(root)
    root.mainloop()
